/* $Id: ClusterStatement.java 509 2012-09-20 14:43:25Z dobashi $
 * create: 2004/09/15
 * (c)2004 Lavans Networks Inc. All Rights Reserved.
 */
package com.lavans.lacoder2.sql.cluster;

import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * @author dobashi
 * @version 1.00
 */
public class ClusterStatement implements Statement, ClusterStatementInterface{
	/** Messageクラスに移動? */
	protected static final String MSG_ERR_REUPDATE="Statementの再生成に失敗。";
	protected static final String MSG_WARN_SWITCH_DB="障害が出たので接続先を切り替えます。";

	/** 処理移譲先。 */
	private Statement st=null;

	/** コネクション。障害時に別のStaementを作るよう依頼する。 */
	private ClusterConnection con = null;

	/**
	 * 保存しておくメソッドのリスト。
	 * 障害が発生した場合、ClusterPreparedStatementに対する操作を操作が行われた
	 * 順序どおりに再実行する必要がある。
	 */
	private List<CalledMethod> methodList = null;

	/** 実行されたsql文。障害時にResultSetを再生成するのに必要。 */
	private String sql = null;

	/** ロガー。debug用 */
	private static Logger logger = LoggerFactory.getLogger(ClusterStatement.class);

	/**
	 * コンストラクタ。
	 * @param st
	 */
	public ClusterStatement(ClusterConnection con, Statement st){
		this.con = con;
		this.st = st;
		methodList = new ArrayList<CalledMethod>();
	}

	/**
	 * DB切替時、新たに取得したStatementに対して
	 * 更新処理を再実行する。
	 * @param
	 */
	public void reupdateStatement(Statement st) throws SQLException{
		try { this.st.close(); } catch (SQLException se) {}
		this.st = st;

		for(int i=0; i<methodList.size(); i++){
			CalledMethod calledMethod = methodList.get(i);
			try{
				calledMethod.invoke(st);	// 戻り値は無視して良い
			}catch (Exception e) {
				logger.error("reupdate failed",e);
				throw new SQLException(MSG_ERR_REUPDATE);
			}
		}
	}

	/**
	 * クラスタリング対応のメソッド実行処理。
	 * @param methodName
	 * @param args
	 * @return
	 * @throws SQLException
	 */
	private Object clusterCall(String methodName, Object[] args, Class<?>[] parameterTypes, boolean saveMethod) throws SQLException{
		Object result = null;
		CalledMethod calledMethod = new CalledMethod(methodName, args, parameterTypes);

		logger.debug(calledMethod.toString());

		try{
			result = calledMethod.invoke(st);
		}catch (Exception e) {
			logger.warn(MSG_WARN_SWITCH_DB, e);
			// try { st.close(); } catch (SQLException se) {}
			con.notifyError(this);	// エラーを通知。ここでstは新しいものになっているはず。
			try{
				// 再度実行。ここでもさらにエラーがでるならSQLExceptionにラップする。
				result = calledMethod.invoke(st);
			}catch (InvocationTargetException e2) {
				// 例外がSQLExceptionならそのままthrow
				Throwable t = e2.getTargetException();
				if(t instanceof SQLException){
					throw (SQLException)t;
				}
				// それ以外ならwrapしてthrow
				SQLException sqle = new SQLException();
				sqle.initCause(e2.getTargetException());
				throw sqle;
			}catch (Exception e2) {
				SQLException sqle = new SQLException();
				sqle.initCause(e2);
				throw sqle;
			}
		}
		if(saveMethod){
			methodList.add(calledMethod);
		}

		return result;
	}

	/**
	 * @see java.sql.Statement#executeQuery(java.lang.String)
	 */
	public ResultSet getAnotherResultSet() throws SQLException {
		logger.debug("Redo st.executeQuery and get ResultSet.\n"+ sql);

		// resultSet内で障害を検知したので、再度コネクションを張り直す。
		con.notifyError(this);	// エラーを通知。ここでstは新しいものになっているはず。
		ResultSet rs = st.executeQuery(sql);

		return rs;
	}

	/**
	 * @see java.sql.Statement#executeQuery(java.lang.String)
	 */
	public ResultSet executeQuery(String sql) throws SQLException {
		ResultSet rs = (ResultSet)clusterCall("executeQuery", new Object[]{sql}, new Class[]{String.class}, true);

		return new ClusterResultSet(this,rs);
	}

	/**
	 * @see java.sql.Statement#executeUpdate(java.lang.String)
	 */
	public int executeUpdate(String sql) throws SQLException {
		return ((Integer)clusterCall("executeUpdate", new Object[]{sql}, new Class[]{String.class}, true)).intValue();
	}

	/**
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int)
	 */
	public int executeUpdate(String sql, int autoGeneratedKeys)
		throws SQLException {
		return ((Integer)clusterCall("executeUpdate", new Object[]{sql, new Integer(autoGeneratedKeys)},
				new Class[]{String.class, Integer.TYPE}, true)).intValue();
	}

	/**
	 * @see java.sql.Statement#executeUpdate(java.lang.String, int[])
	 */
	public int executeUpdate(String sql, int[] columnIndexes)
		throws SQLException {
		return ((Integer)clusterCall("executeUpdate", new Object[]{sql, columnIndexes},
				new Class[]{String.class, int[].class}, true)).intValue();
	}

	/**
	 * @see java.sql.Statement#executeUpdate(java.lang.String, java.lang.String[])
	 */
	public int executeUpdate(String sql, String[] columnNames)
		throws SQLException {
		return ((Integer)clusterCall("executeUpdate", new Object[]{sql, columnNames},
				 new Class[]{String.class, String[].class}, true)).intValue();
	}

	/**
	 * @see java.sql.Statement#execute(java.lang.String, int)
	 */
	public boolean execute(String sql, int autoGeneratedKeys)
		throws SQLException {
		return ((Boolean)clusterCall("execute", new Object[]{sql, new Integer(autoGeneratedKeys)},
				 new Class[]{String.class, Integer.TYPE}, true)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#execute(java.lang.String)
	 */
	public boolean execute(String sql) throws SQLException {
		return ((Boolean)clusterCall("execute", new Object[]{sql},
				 new Class[]{String.class}, true)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#execute(java.lang.String, int[])
	 */
	public boolean execute(String sql, int[] columnIndexes)
		throws SQLException {
			return ((Boolean)clusterCall("execute", new Object[]{sql, columnIndexes},
					 new Class[]{String.class, int[].class}, true)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#execute(java.lang.String, java.lang.String[])
	 */
	public boolean execute(String sql, String[] columnNames)
		throws SQLException {
		return ((Boolean)clusterCall("execute", new Object[]{sql, columnNames},
				 new Class[]{String.class, String[].class}, true)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#getFetchDirection()
	 */
	public int getFetchDirection() throws SQLException {
		return ((Integer)clusterCall("getFetchDirection", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getFetchSize()
	 */
	public int getFetchSize() throws SQLException {
		return ((Integer)clusterCall("getFetchSize", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getMaxFieldSize()
	 */
	public int getMaxFieldSize() throws SQLException {
		return ((Integer)clusterCall("getMaxFieldSize", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getMaxRows()
	 */
	public int getMaxRows() throws SQLException {
		return ((Integer)clusterCall("getMaxRows", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getQueryTimeout()
	 */
	public int getQueryTimeout() throws SQLException {
		return ((Integer)clusterCall("getQueryTimeout", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getResultSetConcurrency()
	 */
	public int getResultSetConcurrency() throws SQLException {
		return ((Integer)clusterCall("getResultSetConcurrency", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getResultSetHoldability()
	 */
	public int getResultSetHoldability() throws SQLException {
		return ((Integer)clusterCall("getResultSetConcurrency", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getResultSetType()
	 */
	public int getResultSetType() throws SQLException {
		return ((Integer)clusterCall("getResultSetType", null, null, false)).intValue();
	}

	/**
	 * @see java.sql.Statement#getUpdateCount()
	 */
	public int getUpdateCount() throws SQLException {
		return ((Integer)clusterCall("getUpdateCount", null, null, false)).intValue();
	}

	/**
	 *
	 * @see java.sql.Statement#cancel()
	 */
	public void cancel() throws SQLException {
		clusterCall("cancel", null, null, true);
	}

	/**
	 * @see java.sql.Statement#clearBatch()
	 */
	public void clearBatch() throws SQLException {
		clusterCall("clearBatch", null, null, true);
		st.clearBatch();
	}

	/**
	 * @see java.sql.Statement#clearWarnings()
	 */
	public void clearWarnings() throws SQLException {
		clusterCall("clearWarnings", null, null, true);
		st.clearWarnings();
	}

	/**
	 * @see java.sql.Statement#close()
	 */
	public void close() throws SQLException {
		clusterCall("close", null, null, true);
		st.close();
		con.remove(this);
	}

	/**
	 * @see java.sql.Statement#getMoreResults()
	 */
	public boolean getMoreResults() throws SQLException {
		return ((Boolean)clusterCall("getMoreResults", null, null, false)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#executeBatch()
	 */
	public int[] executeBatch() throws SQLException {
		return (int[])clusterCall("executeBatch", null, null, true);
	}

	/**
	 * @see java.sql.Statement#setFetchDirection(int)
	 */
	public void setFetchDirection(int direction) throws SQLException {
		clusterCall("setFetchDirection", new Object[]{new Integer(direction)}, new Class[]{Integer.TYPE}, true);
	}

	/**
	 * @see java.sql.Statement#setFetchSize(int)
	 */
	public void setFetchSize(int rows) throws SQLException {
		clusterCall("setFetchSize", new Object[]{new Integer(rows)}, new Class[]{Integer.TYPE}, true);
	}

	/**
	 * @see java.sql.Statement#setMaxFieldSize(int)
	 */
	public void setMaxFieldSize(int max) throws SQLException {
		clusterCall("setMaxFieldSize", new Object[]{new Integer(max)}, new Class[]{Integer.TYPE}, true);
	}

	/**
	 * @see java.sql.Statement#setMaxRows(int)
	 */
	public void setMaxRows(int max) throws SQLException {
		clusterCall("setMaxRows", new Object[]{new Integer(max)}, new Class[]{Integer.TYPE}, true);
	}

	/**
	 * @see java.sql.Statement#setQueryTimeout(int)
	 */
	public void setQueryTimeout(int seconds) throws SQLException {
		clusterCall("setQueryTimeout", new Object[]{new Integer(seconds)}, new Class[]{Integer.TYPE}, true);
	}

	/**
	 * @see java.sql.Statement#getMoreResults(int)
	 */
	public boolean getMoreResults(int current) throws SQLException {
		return ((Boolean)clusterCall("getMoreResults",  new Object[]{new Integer(current)}, new Class[]{Integer.TYPE}, false)).booleanValue();
	}

	/**
	 * @see java.sql.Statement#setEscapeProcessing(boolean)
	 */
	public void setEscapeProcessing(boolean enable) throws SQLException {
		clusterCall("setFetchDirection", new Object[]{new Boolean(enable)}, new Class[]{Boolean.TYPE}, true);
	}


	/**
	 * @see java.sql.Statement#addBatch(java.lang.String)
	 */
	public void addBatch(String sql) throws SQLException {
		clusterCall("addBatch", new Object[]{sql}, new Class[]{String.class}, true);
	}

	/**
	 * @see java.sql.Statement#setCursorName(java.lang.String)
	 */
	public void setCursorName(String name) throws SQLException {
		clusterCall("setCursorName", new Object[]{name}, new Class[]{String.class}, true);
	}


	/**
	 * @see java.sql.Statement#getConnection()
	 */
	public Connection getConnection() throws SQLException {
		return con;
//		return (Connection)clusterCall("getConnection",  null, false);
	}

	/**
	 * @see java.sql.Statement#getGeneratedKeys()
	 */
	public ResultSet getGeneratedKeys() throws SQLException {
		return (ResultSet)clusterCall("getGeneratedKeys", null, null, false);
	}

	/**
	 * @see java.sql.Statement#getResultSet()
	 */
	public ResultSet getResultSet() throws SQLException {
		return (ResultSet)clusterCall("getResultSet", null, null, false);
	}

	/**
	 * @see java.sql.Statement#getWarnings()
	 */
	public SQLWarning getWarnings() throws SQLException {
		return (SQLWarning)clusterCall("getWarnings", null, null, false);
	}
	/**
	 * @return
	 * @throws SQLException
	 * @see java.sql.Statement#isClosed()
	 */
	public boolean isClosed() throws SQLException {
		return st.isClosed();
	}

	/**
	 * @return
	 * @throws SQLException
	 * @see java.sql.Statement#isPoolable()
	 */
	public boolean isPoolable() throws SQLException {
		return st.isPoolable();
	}

	/**
	 * @param iface
	 * @return
	 * @throws SQLException
	 * @see java.sql.Wrapper#isWrapperFor(java.lang.Class)
	 */
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return st.isWrapperFor(iface);
	}

	/**
	 * @param poolable
	 * @throws SQLException
	 * @see java.sql.Statement#setPoolable(boolean)
	 */
	public void setPoolable(boolean poolable) throws SQLException {
		st.setPoolable(poolable);
	}

	/**
	 * @param <T>
	 * @param iface
	 * @return
	 * @throws SQLException
	 * @see java.sql.Wrapper#unwrap(java.lang.Class)
	 */
	@SuppressWarnings("unchecked")
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return (T)this;
	}

	/**
	 * @throws SQLException
	 * @see java.sql.Statement#closeOnCompletion()
	 */
	public void closeOnCompletion() throws SQLException {
		st.closeOnCompletion();
	}

	/**
	 * @return
	 * @throws SQLException
	 * @see java.sql.Statement#isCloseOnCompletion()
	 */
	public boolean isCloseOnCompletion() throws SQLException {
		return st.isCloseOnCompletion();
	}
}
